"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
require("reflect-metadata");
/* tslint:enable */
const function_parameter_1 = require("./function.parameter");
const mapping_option_1 = require("./mapping.option");
class ParameterInjector {
    static setParamsToDestination(target, key, index, destination) {
        const paramNames = mapping_option_1.MappingOption.parseParamNames(target[key].toString());
        const paramTypes = Reflect.getMetadata('design:paramtypes', target, key).map((a) => a.name);
        if (typeof target['methods'] !== 'object') {
            target['methods'] = new Object();
        }
        if (typeof target['methods'][key] !== 'object') {
            target['methods'][key] = new mapping_option_1.MappingOption();
        }
        if (!Array.isArray(target['methods'][key][destination])) {
            target['methods'][key][destination] = new Array();
        }
        target['methods'][key][destination].push(new function_parameter_1.FunctionParameter(index, paramNames[index], paramTypes[index]));
    }
    inject(options, nodeletRequest) {
        const paramObject = {};
        if (options.pathVariables) {
            Object.assign(paramObject, this.parsePath(options.pathVariables, nodeletRequest.getPath(), options.url));
        }
        if (options.requestParams) {
            Object.assign(paramObject, this.parseRequested(options.requestParams, nodeletRequest.getQuery()));
        }
        if (options.requestBodys) {
            Object.assign(paramObject, this.parseRequested(options.requestBodys, nodeletRequest.getBody()));
        }
        const paramArray = [];
        for (const key in paramObject) {
            if (paramObject.hasOwnProperty(key)) {
                paramArray.push(paramObject[key]);
            }
        }
        return paramArray;
    }
    parseRequested(requestedParams, params) {
        const paramObject = {};
        for (const requestedParam of requestedParams) {
            switch (requestedParam.type) {
                case 'Number':
                    paramObject[requestedParam.index] = this.getNumber(params, requestedParam.name);
                    break;
                case 'String':
                    paramObject[requestedParam.index] = this.getString(params, requestedParam.name);
                    break;
                case 'Boolean':
                    paramObject[requestedParam.index] = this.getBoolean(params, requestedParam.name);
                    break;
                case 'Array':
                    paramObject[requestedParam.index] = this.getArray(params, requestedParam.name);
                    break;
                default:
                    paramObject[requestedParam.index] = this.getObject(params, requestedParam.name);
            }
        }
        return paramObject;
    }
    parsePath(requestedParams, paths, path) {
        const paramObject = {};
        path.slice(1).split(/\//).forEach((value, index) => {
            if (value.match(/\{.*\}/)) {
                const paramObjectItem = requestedParams.find((pathvalue) => pathvalue.name === value.slice(1, -1));
                const paramObjectItemName = paramObjectItem.name;
                paramObject[paramObjectItemName] = paths[index];
            }
        });
        return paramObject;
    }
    getNumber(params, key) {
        try {
            /* tslint:disable */
            return parseInt(params[key], 10);
            /* tslint:enable */
        }
        catch (e) {
            return undefined;
        }
    }
    getString(params, key) {
        try {
            return params[key].toString();
        }
        catch (e) {
            return undefined;
        }
    }
    getBoolean(params, key) {
        try {
            switch (params[key]) {
                case 'true': return true;
                case '1': return true;
                case 'false': return false;
                case '0': return false;
                default: return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
    getArray(params, key) {
        try {
            return typeof params[key] === 'undefined' ? params : params[key];
        }
        catch (e) {
            return undefined;
        }
    }
    getObject(params, key) {
        try {
            const object = {};
            for (const objectKey of Object.keys(params)) {
                const objectKeyArray = objectKey.split('.');
                if (key === objectKeyArray[0]) {
                    object[objectKeyArray[1]] = params[objectKey];
                }
            }
            return object;
        }
        catch (e) {
            return undefined;
        }
    }
}
exports.default = ParameterInjector;
