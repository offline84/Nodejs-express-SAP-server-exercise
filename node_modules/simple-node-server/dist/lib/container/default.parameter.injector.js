"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
require("reflect-metadata");
/* tslint:enable */
const mapping_option_1 = require("../classes/mapping.option");
const parameter_map_1 = require("../classes/parameter.map");
const parameter_type_1 = require("../enums/parameter.type");
const default_logger_1 = require("../container/default.logger");
class ParameterInjector {
    static getParameter(controllerName, controllerMethod) {
        return this.parameters.find((pm) => pm.controllerName === controllerName && pm.controllerMethod === controllerMethod);
    }
    static setType(type) {
        if (this.types.findIndex((value) => type.name === value.name) === -1) {
            this.types.push(type);
        }
    }
    static setParamsToDestination(target, key, index, destination) {
        const controllerName = target.constructor.name;
        const controllerMethod = key;
        const paramNames = mapping_option_1.MappingOption.parseParamNames(target[key].toString());
        const paramTypes = Reflect.getMetadata('design:paramtypes', target, key).map((a) => a.name);
        let parameterMap = this.parameters.find((pm) => pm.controllerMethod === controllerMethod && pm.controllerName === controllerName);
        if (!parameterMap)
            parameterMap = new parameter_map_1.ParameterMap(target.constructor.name, key);
        this.parameters.push(parameterMap);
        switch (destination) {
            case parameter_type_1.ParameterType.REQUEST_PARAM:
                parameterMap.requestParams.push({ index, name: paramNames[index], type: paramTypes[index] });
                break;
            case parameter_type_1.ParameterType.PATH_VARIABLE:
                parameterMap.pathVariables.push({ index, name: paramNames[index], type: paramTypes[index] });
                break;
            case parameter_type_1.ParameterType.REQUEST_BODY:
                parameterMap.requestBodys.push({ index, name: paramNames[index], type: paramTypes[index] });
                break;
            case parameter_type_1.ParameterType.INTERNAL:
                parameterMap.internal.push({ index, name: paramNames[index], type: paramTypes[index] });
                break;
            default:
                break;
        }
    }
    static inject(options, nodeletRequest, nodeletResponse, userPrincipal) {
        const paramObject = {};
        if (options.pathVariables) {
            Object.assign(paramObject, this.parsePath(options.pathVariables, nodeletRequest.getPath(), options.url));
        }
        if (options.requestParams) {
            Object.assign(paramObject, this.parseRequested(options.requestParams, nodeletRequest.getQuery()));
        }
        if (options.requestBodys) {
            Object.assign(paramObject, this.parseRequested(options.requestBodys, nodeletRequest.getBody()));
        }
        if (options.internal) {
            Object.assign(paramObject, this.addInternal(options.internal, nodeletRequest, nodeletResponse, userPrincipal));
        }
        const paramArray = [];
        for (const key in paramObject) {
            if (paramObject.hasOwnProperty(key)) {
                paramArray.push(paramObject[key]);
            }
        }
        return paramArray;
    }
    static addInternal(requestedParams, nodeletRequest, nodeletResponse, userPrincipal) {
        const paramObject = {};
        for (const requestedParam of requestedParams) {
            switch (requestedParam.type) {
                case 'NodeletRequest':
                    paramObject[requestedParam.index] = nodeletRequest;
                    break;
                case 'NodeletResponse':
                    paramObject[requestedParam.index] = nodeletResponse;
                    break;
                case 'UserPrincipal':
                    paramObject[requestedParam.index] = userPrincipal;
                    break;
                default:
                    break;
            }
        }
        return paramObject;
    }
    static parseRequested(requestedParams, params) {
        const paramObject = {};
        for (const requestedParam of requestedParams) {
            switch (requestedParam.type) {
                case 'Number':
                    paramObject[requestedParam.index] = this.getNumber(params, requestedParam.name);
                    break;
                case 'String':
                    paramObject[requestedParam.index] = this.getString(params, requestedParam.name);
                    break;
                case 'Boolean':
                    paramObject[requestedParam.index] = this.getBoolean(params, requestedParam.name);
                    break;
                case 'Array':
                    paramObject[requestedParam.index] = this.getArray(params, requestedParam.name);
                    break;
                default:
                    paramObject[requestedParam.index] = this.getObject(params, requestedParam.name, requestedParam.type);
            }
        }
        return paramObject;
    }
    static parsePath(requestedParams, paths, mappedPath) {
        const paramObject = {};
        mappedPath.slice(1).split(/\//).forEach((value, index) => {
            if (value.match(/\{.*\}/)) {
                const paramObjectItem = requestedParams.find((pathvalue) => pathvalue.name === value.slice(1, -1));
                paramObject[paramObjectItem.index] = paths[index];
            }
        });
        return paramObject;
    }
    static getNumber(params, key) {
        try {
            /* tslint:disable */
            return parseInt(params[key], 10);
            /* tslint:enable */
        }
        catch (e) {
            return undefined;
        }
    }
    static getString(params, key) {
        try {
            return params[key].toString();
        }
        catch (e) {
            return undefined;
        }
    }
    static getBoolean(params, key) {
        try {
            switch (params[key]) {
                case 'true': return true;
                case '1': return true;
                case 'false': return false;
                case '0': return false;
                default: return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
    static getArray(params, key) {
        try {
            return typeof params[key] === 'undefined' ? params : params[key];
        }
        catch (e) {
            return undefined;
        }
    }
    static getObject(params, key, type) {
        let requestObject;
        const process = (!params[key]) ? params : params[key];
        try {
            const injectionType = this.types.find((value) => value.name === type);
            requestObject = (!injectionType) ? process : Object.assign(new injectionType.type(), process);
            return requestObject;
        }
        catch (e) {
            default_logger_1.default.error(e);
            return undefined;
        }
    }
}
ParameterInjector.types = [];
ParameterInjector.parameters = [];
exports.default = ParameterInjector;
