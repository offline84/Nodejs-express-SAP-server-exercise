"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const default_logger_1 = require("./default.logger");
const default_parameter_injector_1 = require("./default.parameter.injector");
class Router {
    static register(instance) {
        try {
            const index = this.context.findIndex((value) => value.constructor.name === instance.constructor.name);
            if (index === -1) {
                this.context.push(instance);
                default_logger_1.default.info(colors.white.dim(`registered${new Array(33).join(' ')}| ${instance.constructor.name}`));
            }
            else {
                default_logger_1.default.info(colors.yellow(`${instance.constructor.name} already registered`));
                //this.context[index] = instance
            }
        }
        catch (err) {
            default_logger_1.default.error({ name: err.name, message: err.message, stack: err.stack });
        }
    }
    static fetch(NAME) {
        return this.context.find((value) => value.constructor.name === NAME) || undefined;
    }
    static addMapping(mapping) {
        const index = this.mappings.findIndex((value) => value.url === mapping.url && value.method.toLowerCase() === mapping.method.toLowerCase());
        if (index === -1) {
            const parameterMap = default_parameter_injector_1.default.getParameter(mapping.getControllerName(), mapping.getControllerMethod());
            if (parameterMap)
                mapping.addParameterMap(parameterMap);
            this.mappings.push(mapping);
            const color = this.colorMapping[mapping.method] || 'white';
            if (mapping.getControllerName() !== 'ErrorPages')
                default_logger_1.default.info(colors[color](mapping.toString()));
        }
        else {
            default_logger_1.default.error({ name: 'INSERT ERROR', message: 'add request mapping failed', stack: `url already mapped l32\naddMapping  l30\nContextanyr\n' ${__dirname} ${__filename}` });
        }
    }
    static getMapping(nodeletRequest) {
        const mapping = this.mappings.reduce((actual, current) => this.reduceMappings(actual, current, nodeletRequest));
        if (!mapping || mapping.rank === 0) {
            return this.mappings.find((value) => value.url === '/error/404');
        }
        if (!this.validateMethod(mapping, nodeletRequest.getMethod())) {
            return this.mappings.find((value) => value.url === '/error/405');
        }
        return mapping;
    }
    static reduceMappings(actual, current, nodeletRequest) {
        if (!actual.rank) {
            const actualmatch = `/${nodeletRequest.getPath().join('/')}`.match(new RegExp(actual.url.replace(/{(?:.|\n)*?}/g, '.*')));
            actual.rank = this.rankMatch(actualmatch, actual.url, nodeletRequest.getPath());
        }
        const match = `/${nodeletRequest.getPath().join('/')}`.match(new RegExp(current.url.replace(/{(?:.|\n)*?}/g, '.*')));
        if (!match)
            return actual;
        current.rank = this.rankMatch(match, current.url, nodeletRequest.getPath());
        current.rank = current.method === nodeletRequest.getMethod() ? current.rank + 20 : current.rank;
        current.rank = current.url.slice(1, -1).split('/').length === nodeletRequest.getPath().length ? current.rank + 20 : current.rank;
        if (current.rank === 1000)
            return current;
        return actual.rank >= current.rank ? actual : current;
    }
    static rankMatch(match, url, paths) {
        if (url === `/${paths.join('/')}`)
            return 1000;
        return paths.filter((path) => url.includes(path)).length;
    }
    static validateMethod(mapping, method) {
        if (mapping.method === '')
            return true;
        return mapping.method === method;
    }
}
/*tslint:disable:no-any*/
Router.context = [];
Router.mappings = [];
Router.colorMapping = { GET: 'green', POST: 'yellow', PUT: 'blue', PATCH: 'gray', DELETE: 'red' };
exports.default = Router;
