"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const annotation_inject_1 = require("./lib/annotations/annotation.inject");
const nodelet_response_1 = require("./lib/classes/nodelet.response");
const response_headers_1 = require("./lib/classes/response.headers");
const http_status_1 = require("./lib/enums/http.status");
const response_type_1 = require("./lib/enums/response.type");
const error_pages_1 = require("./lib/internal/error.pages");
const file_pipe_1 = require("./lib/internal/file.pipe");
const request_handler_1 = require("./request.handler");
const request_router_1 = require("./request.router");
const response_handler_1 = require("./response.handler");
const default_authmap_1 = require("./lib/container/default.authmap");
const default_logger_1 = require("./lib/container/default.logger");
const default_router_1 = require("./lib/container/default.router");
class NodeServer {
    constructor(config) {
        this.resourcePath = 'resources';
        this.viewPath = 'views';
        this.requestHandler = new request_handler_1.RequestHandler();
        this.requestRouter = new request_router_1.RequestRouter();
        this.responseHandler = new response_handler_1.ResponseHandler();
        if (config) {
            this.setResourcePath(config.resourcePath);
            this.setViewPath(config.viewPath);
        }
        default_router_1.default.register(new error_pages_1.ErrorPages());
        default_router_1.default.register(new file_pipe_1.FilePipe(this.resourcePath, this.viewPath));
    }
    /**
     * Preparation
     */
    registerController(controllerPath) {
        try {
            /*tslint:disable:all*/
            Promise.resolve().then(() => require(path_1.resolve('dist', controllerPath)));
            /*tslint:enable:all*/
        }
        catch (err) {
            default_logger_1.default.error(err);
        }
    }
    setResourcePath(resourcePath = 'resources') {
        this.resourcePath = resourcePath;
    }
    setViewPath(viewPath = 'views') {
        this.viewPath = viewPath;
    }
    setAuthorization(enabled, key) {
        default_authmap_1.default.authorizationEnabled = enabled;
        if (key)
            default_authmap_1.default.authorizationKey = key;
        else
            default_authmap_1.default.generateKey();
        return default_authmap_1.default.authorizationKey;
    }
    async serve(request, response) {
        if (request.method === 'OPTIONS')
            this.responseHandler.preflight(response);
        const nodeletRequest = await this.requestHandler.getNodeletRequest(request);
        this.requestRouter.route(nodeletRequest, response)
            .then((mappedRoute) => {
            try {
                switch (mappedRoute.outgoing) {
                    case response_type_1.ResponseType.RESPONSE:
                        this.responseHandler.respond(mappedRoute.response, mappedRoute.nodeletResponse);
                        break;
                    case response_type_1.ResponseType.PIPE:
                        this.responseHandler.pipe(mappedRoute.response, mappedRoute.nodeletResponse);
                        break;
                    case response_type_1.ResponseType.REDIRECT:
                        this.responseHandler.redirect(mappedRoute.response, mappedRoute.nodeletResponse);
                        break;
                    default:
                        mappedRoute.nodeletResponse.httpStatus = http_status_1.HttpStatus.NOT_FOUND;
                        mappedRoute.nodeletResponse.body = { error: '404 NOT FOUND' };
                        this.responseHandler.respond(mappedRoute.response, mappedRoute.nodeletResponse);
                        break;
                }
            }
            catch (e) {
                default_logger_1.default.error(e);
            }
        })
            .catch((reason) => {
            const error = reason.nodeletResponse ? reason.nodeletResponse.body : reason instanceof nodelet_response_1.NodeletResponse ? reason.body : reason;
            const errorMessage = this.errorMessage(error);
            this.responseHandler.respond(response, new nodelet_response_1.NodeletResponse().createError(errorMessage));
        });
    }
    errorMessage(reason) {
        if (!reason.stack)
            reason.stack = '';
        return `<!DOCTYPE html>
    <html lang="en" style="font-size: 14px;">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>500 - INTERNAL SERVER ERROR</title>
    </head>
    <body>
      <h1 style="padding: 10px; background: #ccc;">500 - INTERNAL SERVER ERROR</h1>
      <h3 style="padding: 10px;">${reason.name}</h3>
      <p>${reason.message}</p>
      <p>${reason.stack.replace('\n', '</p><p>')}</p>
    </body>
    </html>`;
    }
}
__decorate([
    annotation_inject_1.Inject,
    __metadata("design:type", response_headers_1.ResponseHeaders)
], NodeServer.prototype, "responseHeaders", void 0);
exports.NodeServer = NodeServer;
